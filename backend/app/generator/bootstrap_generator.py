"""
Bootstrap Generator - Refactored Architecture

Generates:
- charts/core/flux-operator/  - Wrapper chart for Flux Operator
- charts/core/flux-instance/  - Custom chart: GitRepository + Git credentials Secret
- bootstrap.sh                - Initial installation script

Key Changes:
- HelmReleases are NOT in flux-instance chart anymore
- Each component gets its own HelmRelease manifest in manifests/releases/<category>/
- Kustomizations are static files in manifests/kustomizations/ (not generated by Helm)
- flux-instance only creates GitRepository (Kustomizations are static YAML files)
"""
import os
import subprocess
from pathlib import Path
from typing import Optional, List, Dict, Any

from .template_engine import render, render_to_file


class GitAuthConfig:
    """Git authentication configuration"""
    def __init__(self, enabled: bool = False, platform: str = "github", custom_url: str = None):
        self.enabled = enabled
        self.platform = platform  # github, gitlab, gitea
        self.custom_url = custom_url


class BootstrapGenerator:
    """Generates the bootstrap infrastructure for Flux"""
    
    FLUX_OPERATOR_VERSION = "0.38.1"
    
    def __init__(self, cluster_name: str, repo_url: str, branch: str = "main", 
                 vendor_charts: bool = False, git_auth: GitAuthConfig = None,
                 skip_git_push: bool = False):
        self.cluster_name = cluster_name
        self.repo_url = repo_url
        self.branch = branch
        self.vendor_charts = vendor_charts
        self.git_auth = git_auth or GitAuthConfig()
        self.skip_git_push = skip_git_push
    
    @property
    def is_ssh(self) -> bool:
        """Check if repo URL is SSH"""
        return self.repo_url.startswith("git@")
    
    @property
    def auth_type(self) -> str:
        """Determine authentication type"""
        if self.is_ssh:
            return "ssh"
        return "https" if self.git_auth.enabled else "none"
    
    def generate_flux_operator(self, charts_path: Path, category: str = "core"):
        """
        Generate Flux Operator wrapper chart.
        
        Creates wrapper structure:
        charts/<category>/flux-operator/
        ├── Chart.yaml
        ├── charts/
        │   └── flux-operator/  (vendored upstream)
        └── values.yaml
        """
        category_path = charts_path / category
        category_path.mkdir(exist_ok=True)
        
        chart_path = category_path / "flux-operator"
        chart_path.mkdir(exist_ok=True)
        (chart_path / "charts").mkdir(exist_ok=True)
        
        # Generate wrapper Chart.yaml
        render_to_file(
            "charts/flux-operator/Chart.yaml.j2",
            chart_path / "Chart.yaml",
            version=self.FLUX_OPERATOR_VERSION
        )
        
        # Generate values.yaml
        render_to_file(
            "charts/flux-operator/values.yaml.j2",
            chart_path / "values.yaml"
        )
        
        # Vendor upstream chart if requested
        if self.vendor_charts:
            self._vendor_flux_operator(chart_path / "charts")
    
    def _vendor_flux_operator(self, dest: Path) -> bool:
        """Download flux-operator chart from OCI registry"""
        try:
            cmd = [
                "helm", "pull", 
                "oci://ghcr.io/controlplaneio-fluxcd/charts/flux-operator",
                "--version", self.FLUX_OPERATOR_VERSION,
                "--untar", "--untardir", str(dest)
            ]
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=120)
            return result.returncode == 0
        except Exception as e:
            print(f"Failed to vendor flux-operator: {e}")
            return False
    
    def generate_flux_instance(self, charts_path: Path, category: str = "core"):
        """
        Generate Flux Instance chart.
        
        This is a custom chart that creates:
        - GitRepository CR
        - Git credentials Secret (optional)
        
        NOTE: Kustomizations are static files in manifests/kustomizations/
        NOTE: HelmReleases are static files in manifests/releases/<category>/
        """
        category_path = charts_path / category
        category_path.mkdir(exist_ok=True)
        
        chart_path = category_path / "flux-instance"
        chart_path.mkdir(exist_ok=True)
        templates_path = chart_path / "templates"
        templates_path.mkdir(exist_ok=True)
        
        # Generate Chart.yaml
        render_to_file(
            "charts/flux-instance/Chart.yaml.j2",
            chart_path / "Chart.yaml",
            version="0.0.1"
        )
        
        # Generate values.yaml (no categories - Kustomizations are static files now)
        render_to_file(
            "charts/flux-instance/values.yaml.j2",
            chart_path / "values.yaml",
            repo_url=self.repo_url,
            branch=self.branch
        )
        
        # Generate templates (only GitRepository and Secret - no Kustomizations)
        template_files = [
            ("gitrepository.yaml", "gitrepository.yaml.j2"),
            ("secret-git-credentials.yaml", "secret-git-credentials.yaml.j2"),
        ]
        
        for output_file, template_file in template_files:
            content = render(f"charts/flux-instance/templates/{template_file}")
            (templates_path / output_file).write_text(content)
    
    def generate_bootstrap_script(self, repo_path: Path, categories: List[Dict[str, Any]] = None):
        """Generate bootstrap.sh script using template"""
        context = {
            "cluster_name": self.cluster_name,
            "repo_url": self.repo_url,
            "branch": self.branch,
            "git_auth_enabled": self.git_auth.enabled,
            "git_platform": self.git_auth.platform,
            "auth_type": self.auth_type,
            "flux_operator_version": self.FLUX_OPERATOR_VERSION,
            "categories": categories or [],
            "skip_git_push": self.skip_git_push,
        }
        
        script_content = render("scripts/bootstrap.sh.j2", **context)
        script_path = repo_path / "bootstrap.sh"
        script_path.write_text(script_content)
        os.chmod(script_path, 0o755)
