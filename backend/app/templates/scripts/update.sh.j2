#!/usr/bin/env bash
#
# K8s Bootstrap Update Script
# Cluster: {{ cluster_name }}
#
# This script updates an existing k8s-bootstrap installation.
# It only modifies changed files and charts, preserving the rest.
#
# Usage:
#   curl -sSL <url> | bash -s -- [OPTIONS]
#   ./update.sh [OPTIONS]
#
# Options:
#   -k, --kubeconfig PATH   Custom kubeconfig
#   -c, --context NAME      Kubernetes context
#   -f, --force             Skip confirmations
#   -d, --dry-run           Show what would change without making changes
#   -h, --help              Show help
#

set -euo pipefail

# ============================================================================
# Colors and Helpers
# ============================================================================
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

info() { echo -e "${BLUE}ℹ${NC} $1"; }
success() { echo -e "${GREEN}✓${NC} $1"; }
warn() { echo -e "${YELLOW}⚠${NC} $1"; }
error() { echo -e "${RED}✗${NC} $1" >&2; }

# ============================================================================
# Configuration
# ============================================================================
CLUSTER_NAME="{{ cluster_name }}"
REPO_URL="{{ repo_url }}"
BRANCH="{{ branch }}"
GIT_AUTH_ENABLED="{{ 'true' if git_auth_enabled else 'false' }}"
GIT_PLATFORM="{{ git_platform }}"

# ============================================================================
# Arguments
# ============================================================================
KUBECONFIG_ARG=""
CONTEXT_ARG=""
FORCE_UPDATE=false
DRY_RUN=false

while [[ $# -gt 0 ]]; do
    case $1 in
        -k|--kubeconfig) KUBECONFIG_ARG="$2"; shift 2 ;;
        -c|--context) CONTEXT_ARG="$2"; shift 2 ;;
        -f|--force) FORCE_UPDATE=true; shift ;;
        -d|--dry-run) DRY_RUN=true; shift ;;
        -h|--help)
            echo "Usage: $0 [OPTIONS]"
            echo ""
            echo "Update an existing k8s-bootstrap installation"
            echo ""
            echo "Options:"
            echo "  -k, --kubeconfig PATH   Custom kubeconfig"
            echo "  -c, --context NAME      Kubernetes context"
            echo "  -f, --force             Skip confirmations"
            echo "  -d, --dry-run           Show what would change"
            echo "  -h, --help              Show help"
            exit 0
            ;;
        *) break ;;
    esac
done

# Helper for kubectl/helm with custom kubeconfig
kctl() {
    local args=()
    [[ -n "$KUBECONFIG_ARG" ]] && args+=(--kubeconfig "$KUBECONFIG_ARG")
    [[ -n "$CONTEXT_ARG" ]] && args+=(--context "$CONTEXT_ARG")
    kubectl "${args[@]}" "$@"
}

hlm() {
    local args=()
    [[ -n "$KUBECONFIG_ARG" ]] && args+=(--kubeconfig "$KUBECONFIG_ARG")
    [[ -n "$CONTEXT_ARG" ]] && args+=(--kube-context "$CONTEXT_ARG")
    helm "${args[@]}" "$@"
}

# ============================================================================
# Pre-flight Checks
# ============================================================================
check_prerequisites() {
    info "Checking prerequisites..."
    
    # Check we're in a bootstrap directory
    if [[ ! -f "bootstrap.sh" ]] || [[ ! -d "charts" ]] || [[ ! -d "manifests" ]]; then
        error "Not in a k8s-bootstrap directory"
        error "Run this script from your cluster's bootstrap directory"
        exit 1
    fi
    
    # Check for git
    if [[ ! -d ".git" ]]; then
        error "No .git directory found"
        error "This directory must be a git repository"
        exit 1
    fi
    
    # Check required tools
    for cmd in kubectl helm git; do
        if ! command -v $cmd &>/dev/null; then
            error "$cmd not installed"
            exit 1
        fi
    done
    
    # Check cluster connectivity
    if ! kctl cluster-info &>/dev/null; then
        error "Cannot connect to Kubernetes cluster"
        exit 1
    fi
    
    success "Prerequisites checked"
}

# ============================================================================
# Git Operations
# ============================================================================
sync_git() {
    # Skip git sync in dry-run mode
    if [[ "$DRY_RUN" == "true" ]]; then
        info "[DRY-RUN] Skipping git sync"
        return
    fi
    
    info "Syncing with remote..."
    
    local current_branch
    current_branch=$(git rev-parse --abbrev-ref HEAD)
    
    if [[ "$current_branch" != "$BRANCH" ]]; then
        warn "Current branch ($current_branch) differs from expected ($BRANCH)"
        if [[ "$FORCE_UPDATE" != "true" ]]; then
            read -p "Continue anyway? [y/N] " -n 1 -r; echo
            [[ ! $REPLY =~ ^[Yy]$ ]] && exit 1
        fi
    fi
    
    # Fetch and check for conflicts
    git fetch origin "$BRANCH" 2>/dev/null || true
    
    local local_commit remote_commit base_commit
    local_commit=$(git rev-parse HEAD)
    remote_commit=$(git rev-parse "origin/$BRANCH" 2>/dev/null || echo "")
    
    if [[ -n "$remote_commit" ]] && [[ "$local_commit" != "$remote_commit" ]]; then
        base_commit=$(git merge-base HEAD "origin/$BRANCH" 2>/dev/null || echo "")
        
        if [[ "$local_commit" == "$base_commit" ]]; then
            # We're behind, need to pull
            info "Pulling remote changes..."
            if [[ "$DRY_RUN" == "true" ]]; then
                info "[DRY-RUN] Would pull from origin/$BRANCH"
            else
                git pull --rebase origin "$BRANCH"
            fi
        elif [[ "$remote_commit" == "$base_commit" ]]; then
            # We're ahead, will push later
            info "Local changes detected, will push after update"
        else
            # Diverged
            warn "Local and remote have diverged"
            if [[ "$FORCE_UPDATE" != "true" ]]; then
                read -p "Attempt rebase? [y/N] " -n 1 -r; echo
                if [[ $REPLY =~ ^[Yy]$ ]]; then
                    git pull --rebase origin "$BRANCH"
                else
                    error "Please resolve conflicts manually"
                    exit 1
                fi
            else
                git pull --rebase origin "$BRANCH"
            fi
        fi
    fi
    
    success "Git synced"
}

# ============================================================================
# File Updates
# ============================================================================
declare -A CHANGED_FILES=()
declare -A UNCHANGED_FILES=()
CHANGED_COUNT=0
UNCHANGED_COUNT=0

check_file_changes() {
    info "Checking for file changes..."
    
{% for file in new_files %}
    check_single_file "{{ file.path }}" "{{ file.checksum }}"
{% endfor %}
    
    info "Files to update: $CHANGED_COUNT"
    info "Files unchanged: $UNCHANGED_COUNT"
}

check_single_file() {
    local file_path="$1"
    local new_checksum="$2"
    
    if [[ -f "$file_path" ]]; then
        local current_checksum
        current_checksum=$(md5sum "$file_path" 2>/dev/null | cut -d' ' -f1 || echo "")
        
        if [[ "$current_checksum" == "$new_checksum" ]]; then
            UNCHANGED_FILES["$file_path"]=1
            ((UNCHANGED_COUNT++)) || true
            return
        fi
    fi
    
    CHANGED_FILES["$file_path"]=1
    ((CHANGED_COUNT++)) || true
}

update_files() {
    info "Updating changed files..."
    
{% for file in new_files %}
    update_single_file "{{ file.path }}" "{{ file.checksum }}" {{ 'true' if file.executable else 'false' }} << '{{ "FILECONTENT_" ~ loop.index }}'
{{ file.content }}
{{ "FILECONTENT_" ~ loop.index }}
{% endfor %}
    
    success "Files updated"
}

update_single_file() {
    local file_path="$1"
    local new_checksum="$2"
    local is_executable="$3"
    local content
    content=$(cat)
    
    # Check if file needs update
    if [[ -v "UNCHANGED_FILES[$file_path]" ]]; then
        return
    fi
    
    if [[ "$DRY_RUN" == "true" ]]; then
        info "[DRY-RUN] Would update: $file_path"
        return
    fi
    
    # Create directory if needed
    local dir
    dir=$(dirname "$file_path")
    [[ -n "$dir" ]] && [[ "$dir" != "." ]] && mkdir -p "$dir"
    
    # Write file
    echo "$content" > "$file_path"
    
    # Set executable if needed
    [[ "$is_executable" == "true" ]] && chmod +x "$file_path"
    
    info "Updated: $file_path"
}

# ============================================================================
# Chart Updates
# ============================================================================
declare -A CHARTS_TO_UPDATE=()
CHARTS_UPDATE_COUNT=0

check_chart_changes() {
    info "Checking for chart version changes..."
    
{% for chart in helm_charts %}
    check_single_chart "{{ chart.id }}" "{{ chart.name }}" "{{ chart.version }}" "{{ chart.repository }}" "{{ chart.category }}"
{% endfor %}
    
    info "Charts to update: $CHARTS_UPDATE_COUNT"
}

check_single_chart() {
    local chart_id="$1"
    local chart_name="$2"
    local new_version="$3"
    local repository="$4"
    local category="$5"
    
    # New structure: charts/<category>/<component>/
    local chart_yaml="charts/${category}/${chart_id}/Chart.yaml"
    
    if [[ -f "$chart_yaml" ]]; then
        # Extract current version from Chart.yaml dependencies
        local current_version
        current_version=$(grep -A5 "dependencies:" "$chart_yaml" | grep "version:" | head -1 | sed 's/.*version: *//' | tr -d '"' || echo "")
        
        # Normalize version (remove 'v' prefix if present)
        current_version="${current_version#v}"
        new_version="${new_version#v}"
        
        if [[ "$current_version" == "$new_version" ]]; then
            info "Chart $chart_id: unchanged (v$current_version)"
            return
        fi
        
        info "Chart $chart_id: $current_version -> $new_version"
    else
        info "Chart $chart_id: new chart"
    fi
    
    CHARTS_TO_UPDATE["$chart_id"]="$chart_name|$new_version|$repository|$category"
    ((CHARTS_UPDATE_COUNT++)) || true
}

update_charts() {
    if [[ $CHARTS_UPDATE_COUNT -eq 0 ]]; then
        info "No charts need updating"
        return
    fi
    
    info "Updating changed charts..."
    
    if [[ "$DRY_RUN" == "true" ]]; then
        for chart_id in "${!CHARTS_TO_UPDATE[@]}"; do
            info "[DRY-RUN] Would update chart: $chart_id"
        done
        return
    fi
    
    helm repo update 2>/dev/null || true
    
    for chart_id in "${!CHARTS_TO_UPDATE[@]}"; do
        local chart_info="${CHARTS_TO_UPDATE[$chart_id]}"
        IFS='|' read -r chart_name chart_version chart_repo chart_category <<< "$chart_info"
        
        # New structure: charts/<category>/<component>/charts/
        local dest_dir="charts/${chart_category}/${chart_id}/charts"
        
        # Remove old chart
        rm -rf "$dest_dir"
        mkdir -p "$dest_dir"
        
        # Download new chart
        if [[ "$chart_repo" == oci://* ]]; then
            helm pull "${chart_repo}/${chart_name}" --version "$chart_version" --untar --untardir "$dest_dir"
        else
            local repo_name
            repo_name=$(echo "$chart_repo" | sed 's|https://||;s|http://||;s|/|-|g;s|\\.|-|g' | cut -c1-30)
            helm repo add "$repo_name" "$chart_repo" 2>/dev/null || true
            helm pull "${repo_name}/${chart_name}" --version "$chart_version" --untar --untardir "$dest_dir"
        fi
        
        success "Updated chart: $chart_id to v$chart_version"
    done
    
    success "Charts updated"
}

# ============================================================================
# Namespaces Chart Version Bump
# ============================================================================
bump_namespaces_version() {
    local chart_yaml="charts/core/namespaces/Chart.yaml"
    
    if [[ ! -f "$chart_yaml" ]]; then
        return
    fi
    
    # Only bump version if there are actual changes to commit
    if git diff --quiet && git diff --staged --quiet; then
        return
    fi
    
    if [[ "$DRY_RUN" == "true" ]]; then
        info "[DRY-RUN] Would bump namespaces chart version"
        return
    fi
    
    info "Bumping namespaces chart version..."
    
    # Generate new version based on timestamp
    local new_version="0.1.$(date +%Y%m%d%H%M%S)"
    
    # Update version in Chart.yaml
    sed -i.bak "s/^version:.*/version: $new_version/" "$chart_yaml"
    rm -f "${chart_yaml}.bak"
    
    info "Namespaces chart version: $new_version"
}

# ============================================================================
# Git Commit and Push
# ============================================================================
commit_and_push() {
    info "Committing changes..."
    
    # Check for changes
    if git diff --quiet && git diff --staged --quiet; then
        info "No changes to commit"
        return
    fi
    
    if [[ "$DRY_RUN" == "true" ]]; then
        info "[DRY-RUN] Would commit and push changes"
        git status --short
        return
    fi
    
    # Stage all changes
    git add -A
    
    # Commit
    local commit_msg="Update k8s-bootstrap configuration

Changed files:
$(for f in "${!CHANGED_FILES[@]}"; do echo "  - $f"; done)

Charts updated:
$(for c in "${!CHARTS_TO_UPDATE[@]}"; do echo "  - $c"; done)"
    
    git commit -m "$commit_msg" || {
        warn "Nothing to commit"
        return
    }
    
    # Push
    info "Pushing to remote..."
    
    # Always check for environment credentials first (useful for CI/CD and testing)
    if [[ -n "${GIT_USERNAME:-}" ]] && [[ -n "${GIT_TOKEN:-}" ]]; then
        local repo_url_with_auth
        repo_url_with_auth=$(echo "$REPO_URL" | sed "s|://|://${GIT_USERNAME}:${GIT_TOKEN}@|")
        git push "$repo_url_with_auth" "$BRANCH"
    elif [[ -n "${GITEA_USER:-}" ]] && [[ -n "${GITEA_PASS:-}" ]]; then
        local repo_url_with_auth
        repo_url_with_auth=$(echo "$REPO_URL" | sed "s|://|://${GITEA_USER}:${GITEA_PASS}@|")
        git push "$repo_url_with_auth" "$BRANCH"
    else
        # Try default push (will work if git credentials are already configured)
        git push origin "$BRANCH"
    fi
    
    success "Changes pushed"
}

# ============================================================================
# Flux Reconciliation
# ============================================================================
apply_new_kustomizations() {
    info "Checking for new Kustomization files..."
    
    if [[ "$DRY_RUN" == "true" ]]; then
        info "[DRY-RUN] Would apply new Kustomizations"
        return
    fi
    
    local kust_dir="manifests/kustomizations"
    if [[ ! -d "$kust_dir" ]]; then
        return
    fi
    
    # Apply any new Kustomization files that don't exist in cluster yet
    for kust_file in $(ls -1 "$kust_dir"/*.yaml 2>/dev/null | sort); do
        local kust_name
        kust_name=$(grep -E "^  name:" "$kust_file" | head -1 | awk '{print $2}')
        
        if [[ -z "$kust_name" ]]; then
            continue
        fi
        
        # Check if this Kustomization already exists in cluster
        if ! kctl get kustomization "$kust_name" -n flux-system &>/dev/null; then
            info "Applying new Kustomization: $kust_name"
            kctl apply -f "$kust_file"
        fi
    done
}

trigger_reconciliation() {
    info "Triggering Flux reconciliation..."
    
    if [[ "$DRY_RUN" == "true" ]]; then
        info "[DRY-RUN] Would trigger Flux reconciliation"
        return
    fi
    
    # Check if Flux is running
    if ! kctl get ns flux-system &>/dev/null; then
        warn "flux-system namespace not found"
        warn "Flux may not be installed. Run bootstrap.sh for initial setup."
        return
    fi
    
    # Apply any new Kustomization files first
    apply_new_kustomizations
    
    # Reconcile GitRepository to pull latest changes
    if kctl get gitrepository flux-system -n flux-system &>/dev/null; then
        kctl annotate gitrepository flux-system -n flux-system \
            reconcile.fluxcd.io/requestedAt="$(date +%s)" --overwrite
        info "Triggered GitRepository reconciliation"
    fi
    
    # Reconcile Kustomizations (namespaces + each category)
    for ks in $(kctl get kustomizations -n flux-system -o name 2>/dev/null | sed 's|kustomization.kustomize.toolkit.fluxcd.io/||'); do
        kctl annotate kustomization "$ks" -n flux-system \
            reconcile.fluxcd.io/requestedAt="$(date +%s)" --overwrite 2>/dev/null || true
        info "Triggered Kustomization/$ks reconciliation"
    done
    
    success "Reconciliation triggered"
}

# ============================================================================
# Status
# ============================================================================
show_status() {
    echo ""
    echo -e "${CYAN}╔══════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${CYAN}║                    Update Summary                            ║${NC}"
    echo -e "${CYAN}╚══════════════════════════════════════════════════════════════╝${NC}"
    echo ""
    
    echo -e "${GREEN}Files updated:${NC} $CHANGED_COUNT"
    echo -e "${GREEN}Files unchanged:${NC} $UNCHANGED_COUNT"
    echo -e "${GREEN}Charts updated:${NC} $CHARTS_UPDATE_COUNT"
    echo ""
    
    if [[ "$DRY_RUN" == "true" ]]; then
        echo -e "${YELLOW}This was a dry run. No changes were made.${NC}"
        echo ""
        return
    fi
    
    echo "Monitor reconciliation:"
    echo "  kubectl get kustomizations,helmreleases -A"
    echo ""
}

# ============================================================================
# Main
# ============================================================================
main() {
    echo ""
    echo -e "${CYAN}╔══════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${CYAN}║           K8s Bootstrap - Update Mode                        ║${NC}"
    echo -e "${CYAN}╠══════════════════════════════════════════════════════════════╣${NC}"
    echo -e "${CYAN}║  Cluster: ${CLUSTER_NAME}${NC}"
    echo -e "${CYAN}║  Repo:    ${REPO_URL}${NC}"
    echo -e "${CYAN}║  Branch:  ${BRANCH}${NC}"
    if [[ "$DRY_RUN" == "true" ]]; then
    echo -e "${CYAN}║  Mode:    ${YELLOW}DRY-RUN${NC}"
    fi
    echo -e "${CYAN}╚══════════════════════════════════════════════════════════════╝${NC}"
    echo ""
    
    check_prerequisites
    sync_git
    check_file_changes
    check_chart_changes
    
    # Confirm update (skip if non-interactive or force mode)
    local total_changes=$((CHANGED_COUNT + CHARTS_UPDATE_COUNT))
    if [[ $total_changes -eq 0 ]]; then
        info "No changes detected"
        exit 0
    fi
    
    if [[ "$FORCE_UPDATE" != "true" ]] && [[ "$DRY_RUN" != "true" ]]; then
        # Check if running interactively (has a terminal)
        if [[ -t 0 ]]; then
            echo ""
            read -p "Apply $total_changes changes? [y/N] " -n 1 -r; echo
            [[ ! $REPLY =~ ^[Yy]$ ]] && exit 0
        else
            # Non-interactive mode (e.g. curl | bash) - auto-apply
            info "Non-interactive mode detected, auto-applying $total_changes changes"
        fi
    fi
    
    update_files
    update_charts
    bump_namespaces_version
    commit_and_push
    trigger_reconciliation
    show_status
    
    if [[ "$DRY_RUN" != "true" ]]; then
        success "Update complete!"
    fi
}

main "$@"
